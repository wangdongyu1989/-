# Memory-Management

为了避免总是在CPU忙碌的时候，也就是在缺页异常发生的时候，临时在来搜寻可供换出的内存页面加以换出，linux内核定期地检查并且预先将若干页面换出，腾出空间，以减轻系统在缺页异常发生时的负担。当然，由于无法确切地预测页面的使用，及时这样做了也还是不能完全杜绝在缺页异常发生时内存没有空闲页面，而只好临时寻找可换成页面的可能。但是，这样毕竟可以减少发生概率。并且，通过选择适当的参数，例如每隔多久换出一次，每次换出多少页面，可以使得缺页异常发生时必须临时寻找页面换出的情况实际上很少发生。为此，在linux内核中设置了一个专司定期将页面换出的“守护神”kswapd。

从原理上说，kswapd相当于一个进程，有其自身的进程控制块task_struct结构，跟其它进程一样搜内核调度。而正因为内核将它按进程来调度，就可以让他在系统相对空闲的时候来运行。不过，与普通的进程相比，kswapd还是有其特殊性。首先，它没有自己独立的地址空间，所以在近代操作系统理论中称为“线程”以示区别。那么，kswapd使用谁的地址空间呢？它使用的是内核的空间。在这一点上，它与中断服务程序相似。其次，它的代码是静态地连接在内核中的，可以直接使用内核中的各种子程序，而不像普通的进程那样只能通过系统调用，使用预先定义的一组功能。

本节讲诉kswapd受内核调度而运行并走完一条例行路线的全过程。

线程kswapd的源代码基本上都在mm/vmscan.c中。先来看它的建立：

```c++
static int __init kswapd_init(void)
{
     printk("Starting kswapd v1.8\n");
     swap_setup();
     kernel_thread(kswapd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
     kernel_thread(kreclaimd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
     return 0;
}
```
函数kswapd_init()是在系统初始化期间受到调用的，它主要做两件事。第一件是在swap_setup()中根据物理内存的大小设定一个全局量page_cluster：

```c++
[kswapd_init()>swap_setup()]
 /*
  * Perform any setup for the swap system
  */
void __init swap_setup(void)
{
     /* Use a smaller cluster for memory <16MB or <32MB */
     if (num_physpages < ((16 * 1024 * 1024) >> PAGE_SHIFT))
          page_cluster = 2;
     else if (num_physpages < ((32 * 1024 * 1024) >> PAGE_SHIFT))
          page_cluster = 3;
     else
          page_cluster = 4;
}
```
