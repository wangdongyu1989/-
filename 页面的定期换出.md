# Memory-Management

为了避免总是在CPU忙碌的时候，也就是在缺页异常发生的时候，临时在来搜寻可供换出的内存页面加以换出，linux内核定期地检查并且预先将若干页面换出，腾出空间，以减轻系统在缺页异常发生时的负担。当然，由于无法确切地预测页面的使用，及时这样做了也还是不能完全杜绝在缺页异常发生时内存没有空闲页面，而只好临时寻找可换成页面的可能。但是，这样毕竟可以减少发生概率。并且，通过选择适当的参数，例如每隔多久换出一次，每次换出多少页面，可以使得缺页异常发生时必须临时寻找页面换出的情况实际上很少发生。为此，在linux内核中设置了一个专司定期将页面换出的“守护神”kswapd。

从原理上说，kswapd相当于一个进程，有其自身的进程控制块task_struct结构，跟其它进程一样搜内核调度。而正因为内核将它按进程来调度，就可以让他在系统相对空闲的时候来运行。不过，与普通的进程相比，kswapd还是有其特殊性。首先，它没有自己独立的地址空间，所以在近代操作系统理论中称为“线程”以示区别。那么，kswapd使用谁的地址空间呢？它使用的是内核的空间。在这一点上，它与中断服务程序相似。其次，它的代码是静态地连接在内核中的，可以直接使用内核中的各种子程序，而不像普通的进程那样只能通过系统调用，使用预先定义的一组功能。

本节讲诉kswapd受内核调度而运行并走完一条例行路线的全过程。

线程kswapd的源代码基本上都在mm/vmscan.c中。先来看它的建立：

```c++
static int __init kswapd_init(void)
{
     printk("Starting kswapd v1.8\n");
     swap_setup();
     kernel_thread(kswapd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
     kernel_thread(kreclaimd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
     return 0;
}
```
函数kswapd_init()是在系统初始化期间受到调用的，它主要做两件事。第一件是在swap_setup()中根据物理内存的大小设定一个全局量page_cluster：

```c++
[kswapd_init()>swap_setup()]
 /*
  * Perform any setup for the swap system
  */
void __init swap_setup(void)
{
     /* Use a smaller cluster for memory <16MB or <32MB */
     if (num_physpages < ((16 * 1024 * 1024) >> PAGE_SHIFT))
          page_cluster = 2;
     else if (num_physpages < ((32 * 1024 * 1024) >> PAGE_SHIFT))
          page_cluster = 3;
     else
          page_cluster = 4;
}
```

这是一个跟磁盘设备驱动有关的参数。由于读磁盘时先要经过寻到，并且寻道是个比较费时间的操作，所以如果每次只读一个页面是不经济的。比较好的办法是既然读了干脆多读几个页面，称为“预读”。但是预读意味着每次需要暂存更多的内存页面，所以需要决定一个适当的数量，而根据物理内存本身的大小来确定这个参数显然是合理的。第二件事就是创建线程kswapd，这是由kernel_thread()来完成。这里还创建了另一个线程kreclaimd，也是跟存储管理有关，不过不像kswapd那么复杂和重要。这里暂且假定kswapd就此建立了，并且从函数kswapd()开始执行。其代码在mm/vmscan.c中：

```c++
/*
 * The background pageout daemon, started as a kernel thread
 * from the init process.
 *
 * This basically trickles out pages so that we have _some_
 * free memory available even if there is no other activity
 * that frees anything up. This is needed for things like routing
 * etc, where we otherwise might have all activity going on in
 * asynchronous contexts that cannot page things out.
 *
 * If there are applications that are active memory-allocators
 * (most normal use), this basically shouldn't matter.
 */
int kswapd(void *unused)
{
    struct task_struct *tsk = current;

    tsk->session = 1;
    tsk->pgrp = 1;
    strcpy(tsk->comm, "kswapd");
    sigfillset(&tsk->blocked);
    kswapd_task = tsk;

    /*
     * Tell the memory management that we're a "memory allocator",
     * and that if we need more memory we should get access to it
     * regardless (see "__alloc_pages()"). "kswapd" should
     * never get caught in the normal page freeing logic.
     *
     * (Kswapd normally doesn't need memory anyway, but sometimes
     * you need a small amount of memory in order to be able to
     * page out something else, and this flag essentially protects
     * us from recursively trying to free more memory as we're
     * trying to free the first piece of memory in the first place).
     */
    tsk->flags |= PF_MEMALLOC;

    /*
     * Kswapd main loop.
     */
    for (;;) {
      static int recalc = 0;

      /* If needed, try to free some memory. */
      if (inactive_shortage() || free_shortage()) {
          int wait = 0;
      /* Do we need to do some synchronous flushing? */ 
      if (waitqueue_active(&kswapd_done))
          wait = 1;
      do_try_to_free_pages(GFP_KSWAPD, wait);
      }

      /*
       * Do some (very minimal) background scanning. This
       * will scan all pages on the active list once
       * every minute. This clears old referenced bits
       * and moves unused pages to the inactive list.
       */
       refill_inactive_scan(6, 0);

      /* Once a second, recalculate some VM stats. */
      if (time_after(jiffies, recalc + HZ)) {
          recalc = jiffies;
          recalculate_vm_stats();
     }

     /*
      * Wake up everybody waiting for free memory
      * and unplug the disk queue.
      */
     wake_up_all(&kswapd_done);
     run_task_queue(&tq_disk);

     /*
      * We go to sleep if either the free page shortage
      * or the inactive page shortage is gone. We do this
      * because:
      * 1) we need no more free pages   or
      * 2) the inactive pages need to be flushed to disk,
      *    it wouldn't help to eat CPU time now ...
      *
      * We go to sleep for one second, but if it's needed
      * we'll be woken up earlier...
      */
     if (!free_shortage() || !inactive_shortage()) {
           interruptible_sleep_on_timeout(&kswapd_wait, HZ);
     /*
      * If we couldn't free enough memory, we see if it was
      * due to the system just not having enough memory.
      * If that is the case, the only solution is to kill
      * a process (the alternative is enternal deadlock).
      *
      * If there still is enough memory around, we just loop
      * and try free some more memory...
      */
      } else if (out_of_memory()) {
        oom_kill();
      }
   }
}
```
在一些简单的初始化操作以后，程序便进入一个无限循环。在每次循环的末尾一般都会调用interruptible_sleep_on_timeout()进入睡眠，让内核自由地调度别的进程运行。但是内核在一定时间以后又会唤醒并调度kswapd继续运行，这时候kswapd就又回到这无限循环开始的位置。那么，这“一定时间”是多长呢，这就是常数HZ。HZ决定
了内核中每秒有多少次时钟中断。用户可以在编译内核前的系统配置阶段改变其数值，但是一经编译就确定下来了。所以，在调用interruptiable_sleep_on_timeout()时的参数为HZ，表示1秒中以后又要调度kswapd继续运行。换言之，对interruptible_sleep_on_timeout()的调度一进去就得1秒钟以后才回来。但是，在有些情况下内核也会在不到1秒钟时就把它唤醒，那样kswapd就会提前返回并开始新的一轮循环。所以，这个循环至少每隔1秒钟执行一遍，这就是kswapd的例行路线。

那么，kswapd在至少每秒一次的例行路线中做些什么呢？可以把它分成两部分。第一部分是在发现物理页面已经短缺的情况下才进行的，目的在于裕兴找出若干页面，且将这些页面的樱色断开，使这些物理页面从活跃状态转入不活跃状态，为页面的换出做好准备。第二部分是每次都要执行的，目的正在于把已经处于不活跃状态的“脏”页写入交换设备，使他们成为不活跃“干净”页面继续缓存，或进一步回收一些这样的页面成为空闲页面。
