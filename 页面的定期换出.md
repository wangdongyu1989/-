# Memory-Management

为了避免总是在CPU忙碌的时候，也就是在缺页异常发生的时候，临时在来搜寻可供换出的内存页面加以换出，linux内核定期地检查并且预先将若干页面换出，腾出空间，以减轻系统在缺页异常发生时的负担。当然，由于无法确切地预测页面的使用，及时这样做了也还是不能完全杜绝在缺页异常发生时内存没有空闲页面，而只好临时寻找可换成页面的可能。但是，这样毕竟可以减少发生概率。并且，通过选择适当的参数，例如每隔多久换出一次，每次换出多少页面，可以使得缺页异常发生时必须临时寻找页面换出的情况实际上很少发生。为此，在linux内核中设置了一个专司定期将页面换出的“守护神”kswapd。

从原理上说，kswapd相当于一个进程，有其自身的进程控制块task_struct结构，跟其它进程一样受内核调度。而正因为内核将它按进程来调度，就可以让他在系统相对空闲的时候来运行。不过，与普通的进程相比，kswapd还是有其特殊性。首先，它没有自己独立的地址空间，所以在近代操作系统理论中称为“线程”以示区别。那么，kswapd使用谁的地址空间呢？它使用的是内核的空间。在这一点上，它与中断服务程序相似。其次，它的代码是静态地连接在内核中的，可以直接使用内核中的各种子程序，而不像普通的进程那样只能通过系统调用，使用预先定义的一组功能。

本节讲诉kswapd受内核调度而运行并走完一条例行路线的全过程。

线程kswapd的源代码基本上都在mm/vmscan.c中。先来看它的建立：

```c++
static int __init kswapd_init(void)
{
     printk("Starting kswapd v1.8\n");
     swap_setup();
     kernel_thread(kswapd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
     kernel_thread(kreclaimd, NULL, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);
     return 0;
}
```
函数kswapd_init()是在系统初始化期间受到调用的，它主要做两件事。第一件是在swap_setup()中根据物理内存的大小设定一个全局量page_cluster：

```c++
[kswapd_init()>swap_setup()]
 /*
  * Perform any setup for the swap system
  */
void __init swap_setup(void)
{
     /* Use a smaller cluster for memory <16MB or <32MB */
     if (num_physpages < ((16 * 1024 * 1024) >> PAGE_SHIFT))
          page_cluster = 2;
     else if (num_physpages < ((32 * 1024 * 1024) >> PAGE_SHIFT))
          page_cluster = 3;
     else
          page_cluster = 4;
}
```

这是一个跟磁盘设备驱动有关的参数。由于读磁盘时先要经过寻到，并且寻道是个比较费时间的操作，所以如果每次只读一个页面是不经济的。比较好的办法是既然读了干脆多读几个页面，称为“预读”。但是预读意味着每次需要暂存更多的内存页面，所以需要决定一个适当的数量，而根据物理内存本身的大小来确定这个参数显然是合理的。第二件事就是创建线程kswapd，这是由kernel_thread()来完成。这里还创建了另一个线程kreclaimd，也是跟存储管理有关，不过不像kswapd那么复杂和重要。这里暂且假定kswapd就此建立了，并且从函数kswapd()开始执行。其代码在mm/vmscan.c中：

```c++
/*
 * The background pageout daemon, started as a kernel thread
 * from the init process.
 *
 * This basically trickles out pages so that we have _some_
 * free memory available even if there is no other activity
 * that frees anything up. This is needed for things like routing
 * etc, where we otherwise might have all activity going on in
 * asynchronous contexts that cannot page things out.
 *
 * If there are applications that are active memory-allocators
 * (most normal use), this basically shouldn't matter.
 */
int kswapd(void *unused)
{
    struct task_struct *tsk = current;

    tsk->session = 1;
    tsk->pgrp = 1;
    strcpy(tsk->comm, "kswapd");
    sigfillset(&tsk->blocked);
    kswapd_task = tsk;

    /*
     * Tell the memory management that we're a "memory allocator",
     * and that if we need more memory we should get access to it
     * regardless (see "__alloc_pages()"). "kswapd" should
     * never get caught in the normal page freeing logic.
     *
     * (Kswapd normally doesn't need memory anyway, but sometimes
     * you need a small amount of memory in order to be able to
     * page out something else, and this flag essentially protects
     * us from recursively trying to free more memory as we're
     * trying to free the first piece of memory in the first place).
     */
    tsk->flags |= PF_MEMALLOC;

    /*
     * Kswapd main loop.
     */
    for (;;) {
      static int recalc = 0;

      /* If needed, try to free some memory. */
      if (inactive_shortage() || free_shortage()) {
          int wait = 0;
      /* Do we need to do some synchronous flushing? */ 
      if (waitqueue_active(&kswapd_done))
          wait = 1;
      do_try_to_free_pages(GFP_KSWAPD, wait);
      }

      /*
       * Do some (very minimal) background scanning. This
       * will scan all pages on the active list once
       * every minute. This clears old referenced bits
       * and moves unused pages to the inactive list.
       */
       refill_inactive_scan(6, 0);

      /* Once a second, recalculate some VM stats. */
      if (time_after(jiffies, recalc + HZ)) {
          recalc = jiffies;
          recalculate_vm_stats();
     }

     /*
      * Wake up everybody waiting for free memory
      * and unplug the disk queue.
      */
     wake_up_all(&kswapd_done);
     run_task_queue(&tq_disk);

     /*
      * We go to sleep if either the free page shortage
      * or the inactive page shortage is gone. We do this
      * because:
      * 1) we need no more free pages   or
      * 2) the inactive pages need to be flushed to disk,
      *    it wouldn't help to eat CPU time now ...
      *
      * We go to sleep for one second, but if it's needed
      * we'll be woken up earlier...
      */
     if (!free_shortage() || !inactive_shortage()) {
           interruptible_sleep_on_timeout(&kswapd_wait, HZ);
     /*
      * If we couldn't free enough memory, we see if it was
      * due to the system just not having enough memory.
      * If that is the case, the only solution is to kill
      * a process (the alternative is enternal deadlock).
      *
      * If there still is enough memory around, we just loop
      * and try free some more memory...
      */
      } else if (out_of_memory()) {
        oom_kill();
      }
   }
}
```
在一些简单的初始化操作以后，程序便进入一个无限循环。在每次循环的末尾一般都会调用interruptible_sleep_on_timeout()进入睡眠，让内核自由地调度别的进程运行。但是内核在一定时间以后又会唤醒并调度kswapd继续运行，这时候kswapd就又回到这无限循环开始的位置。那么，这“一定时间”是多长呢，这就是常数HZ。HZ决定
了内核中每秒有多少次时钟中断。用户可以在编译内核前的系统配置阶段改变其数值，但是一经编译就确定下来了。所以，在调用interruptiable_sleep_on_timeout()时的参数为HZ，表示1秒中以后又要调度kswapd继续运行。换言之，对interruptible_sleep_on_timeout()的调度一进去就得1秒钟以后才回来。但是，在有些情况下内核也会在不到1秒钟时就把它唤醒，那样kswapd就会提前返回并开始新的一轮循环。所以，这个循环至少每隔1秒钟执行一遍，这就是kswapd的例行路线。

那么，kswapd在至少每秒一次的例行路线中做些什么呢？可以把它分成两部分。第一部分是在发现物理页面已经短缺的情况下才进行的，目的在于裕兴找出若干页面，且将这些页面的樱色断开，使这些物理页面从活跃状态转入不活跃状态，为页面的换出做好准备。第二部分是每次都要执行的，目的正在于把已经处于不活跃状态的“脏”页写入交换设备，使他们成为不活跃“干净”页面继续缓存，或进一步回收一些这样的页面成为空闲页面。

先看第一部分，首先检查内存中可供分配或周转的物理页面是否短缺：

```c++
[kswapd()>inactive_shortage()]
 /*
  * How many inactive pages are we short?
  */
int inactive_shortage(void)
{
    int shortage = 0;

    shortage += freepages.high;
    shortage += inactive_target;
    shortage -= nr_free_pages();
    shortage -= nr_inactive_clean_pages();
    shortage -= nr_inactive_dirty_pages;

    if (shortage > 0)
       return shortage;
    return 0;
}
```

系统中应该维持的物理页面供应量有两个全局量确定，那就是freepages.high和inactive_target,分别为空闲页面的数量和不活跃页面的数量，两者之和为正常情况下潜在的供应量。而这些内存页面来源有三个方面。一方面是当前尚存的空闲页面，这是立即就可以分配的页面。这些页面分散在各个页面管理区中，并且合并成地址连续，大小为2,4,8...个页面的页面块，其数量由nr_free_pages()加以统计。另一方面是现有不活跃“干净”页面，这些页面本质上是马上可以分配的页面，但是页面中的内容
可能还会用到，所以多保留一些这样的页面有助于减少从交换设备的读入。这些页面也分散在各个页面管理区，但是不合并成块，其数量由nr_inactive_clean_pages()加以统计。最后是现有的不活跃“脏”页面，这些页面要先加以“净化”，即写入交换设备后才能投入分配。这种页面全部在同一队列中，内核中的全局量nr_inactive_dirty_pages记录着当前此类页面的数量。上述两个函数的代码都在mm/page_alloc.c中。

不过，光维持潜在的物理页面供应总量还不够，还是通过free_shortage()检查是否有某个具体管理区中有严重的短缺，即直接可供分配的页面数量（除不活跃“脏”页面以外）是否小于一个最低限度，这个函数的代码在mm/vmscan.c中。

如果发现可供分配的内存页面短缺，那就要设法释放和换出若干页面，这是通过do_try_to_free_pages()完成的。不过在此之前还有调用waitqueue_active(),看看kswapd_done队列中是否有函数在等待执行，并把查看结果作为参数传递给do_try_to_free_pages()。在内核中有几个特殊的队列，内核中各个部分（主要是设备驱动）可以把一些底层函数挂入这样的队列，是的这些函数在某种时间发生时就能的到执行。而kswapd_done，就正是这样的一个队列。凡是挂入这个队列的函数，在kswapd每完成一趟例行的操作时就能得到执行。

```c++
[kswapd()>waitqueue_active()]
static inline int waitqueue_active(wait_queue_head_t *q)
{
    #if WAITQUEUE_DEBUG
    if (!q)
       WQ_BUG();
    CHECK_MAGIC_WQHEAD(q);
    #endif
    return !list_empty(&q->task_list);
}
```

下面就是调用do_try_to_free_pages(),试图腾出一些内存页面。

```c++
[kswapd()>do_try_to_free_pages()]
static int do_try_to_free_pages(unsigned int gfp_mask, int user)
{
    int ret = 0;

    /*
     * If we're low on free pages, move pages from the
     * inactive_dirty list to the inactive_clean list.
     *
     * Usually bdflush will have pre-cleaned the pages
     * before we get around to moving them to the other
     * list, so this is a relatively cheap operation.
     */
    if (free_shortage() || nr_inactive_dirty_pages > nr_free_pages() +  nr_inactive_clean_pages())
        ret += page_launder(gfp_mask, user);
    /*
     * If needed, we move pages from the active list
     * to the inactive list. We also "eat" pages from
     * the inode and dentry cache whenever we do this.
     */
    if (free_shortage() || inactive_shortage()) {
        shrink_dcache_memory(6, gfp_mask);
        shrink_icache_memory(6, gfp_mask);
        ret += refill_inactive(gfp_mask, user);
    } else {
      /*
       * Reclaim unused slab cache memory.
       */
       kmem_cache_reap(gfp_mask);
       ret = 1;
    }

    return ret;
}
```

将活跃页面的映射断开，使之转入不活跃状态，甚至进而换出到交换设备上，使不得已而为之，因为谁也不能精确地预测到底哪一些页面是适合的换出对象。虽然一般而言“最近最少用的”是个有效的标准，但也不是“放诸四海而皆准”。所以，能够不动“现役”页面是最理想的。基于这样的考虑，这是所做的是先易后难，逐步加强力度。首先是调用page_launder(),试图把已经转入不活跃状态的“脏”页面“洗净”，使他们变成立即可以分配的页面。这个函数一方面（基本上）定期地受到kswapd()调用，一方面在每当需要分配内存页面，而又无页面可供分配时，临时地受到调用。

```c++
#define MAX_LAUNDER (4 * (1 << page_cluster))
int page_launder(int gfp_mask, int sync)
{
    int launder_loop, maxscan, cleaned_pages, maxlaunder;
    int can_get_io_locks;
    struct list_head * page_lru;
    struct page * page;

    /*
     * We can only grab the IO locks (eg. for flushing dirty
     * buffers to disk) if __GFP_IO is set.
     */
    can_get_io_locks = gfp_mask & __GFP_IO;

    launder_loop = 0;
    maxlaunder = 0;
    cleaned_pages = 0;

    dirty_page_rescan:
    spin_lock(&pagemap_lru_lock);
    maxscan = nr_inactive_dirty_pages;
    while ((page_lru = inactive_dirty_list.prev) != &inactive_dirty_list && maxscan-- > 0) {
          page = list_entry(page_lru, struct page, lru);

    /* Wrong page on list?! (list corruption, should not happen) */
    if (!PageInactiveDirty(page)) {
         printk("VM: page_launder, wrong page on list.\n");
         list_del(page_lru);
         nr_inactive_dirty_pages--;
         page->zone->inactive_dirty_pages--;
         continue;
    }

    /* Page is or was in use?  Move it to the active list. */
    if (PageTestandClearReferenced(page) || page->age > 0 ||  (!page->buffers && page_count(page) > 1) ||
    page_ramdisk(page)) {
        del_page_from_inactive_dirty_list(page);
        add_page_to_active_list(page);
        continue;
    }

    /*
     * The page is locked. IO in progress?
     * Move it to the back of the list.
     */
    if (TryLockPage(page)) { 
       list_del(page_lru);
       list_add(page_lru, &inactive_dirty_list);
       continue;
    }

    /*
     * Dirty swap-cache page? Write it out if
     * last copy..
     */
    if (PageDirty(page)) {
        int (*writepage)(struct page *) = page->mapping->a_ops->writepage;
        int result;

        if (!writepage)
            goto page_active;

        /* First time through? Move it to the back of the list */
        if (!launder_loop) {
                list_del(page_lru);
                list_add(page_lru, &inactive_dirty_list);
                UnlockPage(page);
                continue;
        }

        /* OK, do a physical asynchronous write to swap.  */
        ClearPageDirty(page);
        page_cache_get(page);
        spin_unlock(&pagemap_lru_lock);

        result = writepage(page);
        page_cache_release(page);

        /* And re-start the thing.. */
        spin_lock(&pagemap_lru_lock);
        if (result != 1)
            continue;
        /* writepage refused to do anything */
        set_page_dirty(page);
        goto page_active;
   }

    /*
     * If the page has buffers, try to free the buffer mappings
     * associated with this page. If we succeed we either free
     * the page (in case it was a buffercache only page) or we
     * move the page to the inactive_clean list.
     *
     * On the first round, we should free all previously cleaned
     * buffer pages
     */
    if (page->buffers) { 
          int wait, clearedbuf;
          int freed_page = 0;
    /*
     * Since we might be doing disk IO, we have to
     * drop the spinlock and take an extra reference
     * on the page so it doesn't go away from under us.
     */
          del_page_from_inactive_dirty_list(page);
          page_cache_get(page);
          spin_unlock(&pagemap_lru_lock);

      /* Will we do (asynchronous) IO? */
      if (launder_loop && maxlaunder == 0 && sync)
             wait = 2; /* Synchrounous IO */
      else if (launder_loop && maxlaunder-- > 0)
             wait = 1; /* Async IO */
      else
             wait = 0; /* No IO */

      /* Try to free the page buffers. */
      clearedbuf = try_to_free_buffers(page, wait);

    /*
     * Re-take the spinlock. Note that we cannot
     * unlock the page yet since we're still
     * accessing the page_struct here...
     */
     spin_lock(&pagemap_lru_lock);

     /* The buffers were not freed. */
     if (!clearedbuf) {
        add_page_to_inactive_dirty_list(page);

     /* The page was only in the buffer cache. */
    } else if (!page->mapping) {
          atomic_dec(&buffermem_pages);
          freed_page = 1;
          cleaned_pages++;

     /* The page has more users besides the cache and us. */
    } else if (page_count(page) > 2) {
          add_page_to_active_list(page);

     /* OK, we "created" a freeable page. */
   } else /* page->mapping && page_count(page) == 2 */ { 
          add_page_to_inactive_clean_list(page);
          cleaned_pages++;
   }

    /*
     * Unlock the page and drop the extra reference.
     * We can only do it here because we ar accessing
     * the page struct above.
     */
    UnlockPage(page);
    page_cache_release(page);

    /*
     * If we're freeing buffer cache pages, stop when
     * we've got enough free memory.
     */
    if (freed_page && !free_shortage())
       break;
       continue;
    } else if (page->mapping && !PageDirty(page)) {
    /*
     * If a page had an extra reference in
     * deactivate_page(), we will find it here.
     * Now the page is really freeable, so we
     * move it to the inactive_clean list.
     */
      del_page_from_inactive_dirty_list(page);
      add_page_to_inactive_clean_list(page);
      UnlockPage(page);
      cleaned_pages++;
    } else {
page_active:
    /*
     * OK, we don't know what to do with the page.
     * It's no use keeping it here, so we move it to
     * the active list.
     */
     del_page_from_inactive_dirty_list(page);
     add_page_to_active_list(page);
     UnlockPage(page);
   }
   }
spin_unlock(&pagemap_lru_lock);
```

代码中局部量cleaned_pages用来累计被“洗清”的页面数量。另一个局部量launder_loop用来控制扫描不活跃“脏”页面队列的次数。在第一趟扫描时launcher_loop为0，如果有必要进行第二趟扫描，则将其设成1并转回标号dirty_page_rescan处，开始又一次扫描。

对不活跃“脏”页面队列的扫描时通过一个while循环进行的。由于在循环中会把有些页面从当前位置移到队列的尾部，所以除沿着链接指针扫描还要对数量加以控制，才能避免重复处理同一页面，甚至陷入死循环，这就是变量maxscan的作用。

对于队列中的每一个页面，首先要检查它的PG_inactive_dirty标记位为1，否则就根本不应该出现在这个队列中；着一定是出了什么毛病，所以把它从队列中删除。除此之外，对于正常的不活跃“脏”页面，则要依次做下述的检查并做相应的处理。

（1）有些页面虽然已经进入不活跃“脏”页面队列，但是由于情况已经变化，或者当初进入这个队列本来就是“冤家错案”，因而需要回到活跃页面队列中。这样的页面有：页面在进入不活跃“脏”页面队列之后又受到了访问，即发生了以此页面为目标的缺页异常，从而恢复了该页面的映射。页面的“寿命”还未耗尽。页面的page结构中有个字段age,其数值与页面受访问的频繁程度有关。页面并不用作读/写文件的缓冲，而页面的使用计数却又大约1。说明页面在失少一个进程的映射表中有映射。如前所述，一个页面的使用计数在分配时设成1，以后对该页面的每一次使这个计数加1，包括将页面用作读/写文件的缓冲。如果一个页面没有用作读/写文件的缓冲，那么只要计数大于1就必定还有进程在使用这个页面。页面在受到进程用户空间映射的同时又用于ramdisk，即用内存空间来模拟磁盘，这种页面当然不应该换出到磁盘上。

（2）页面已被锁住，所以TryLockPage()返回1，这表明正在对此页面进行操作，如输入/输出，这样的页面应该留在不活跃“脏”页面队列中，但是把它移到队列的尾部。注意，对于未被锁住的页面，现在已经锁上了。

（3）如果页面仍是“脏”的，即page结构的PG_dirty标记位为1，则原则上将其写出到交换设备上，但还有些特殊情况要考虑。首先，所属的address_space数据结构必须提供页面写出操作的函数，否则就只好转到page_active处，将页面送回活跃页面队列中。对于一般的页面交换，所属的address_space数据结构为swapper_space,其address_space_operations结构为swap_aops,所提供的页面写出操作为swap_writepage(),过这一“关”是没有问题的。在这一趟扫描中，只是把页面移到同一队列的尾部，而并不写出页面。如果进行第二趟扫描的话，那就真的要把页面写出去了。写之前先通过先通过ClearPageDirty()把页面的PG_dirty标记位清成0，然后通过由所属address_space数据结构所提供的函数把页面写出去。根据页面的不同使用目的，例如普通的用户空间页面，或者通过mmap（）建立的文件映射以及文件系统的读/写，具体的操作也不一样。这个写操作可能是同步的，也有可能是异步的，但总是需要一定的时间才能完成，在此期间内核有可能再次进入page_launcher(),所以需要放置这个页面再写一次。这就是把页面的PG_dirty标记位清成0的目的。这样，就不会把同一个页面写出两次了。此外，还要考虑页面写出失败的可能，具体的函数在写出失败时应该返回1，使page_launcher()可以恢复页面的PG_dirty标记位并将其退还给活跃页面队列中。

（4）如果页面不在是“脏”的，并且又是用作文件读/写缓冲的页面，则先使它多里不活跃“脏”页面队列，在通过try_to_free_buffers()试图将页面释放。如果不能释放则根据返回值将其退回不活跃“脏”页面队列，或者链入活跃页面队列，或者不活跃“干净”页面队列。如果释放成功，则页面的使用计数已经在try_to_free_buffers中减1，page_cache_release再使其减1就达到了0，从而将页面释放回到空闲页面队列中。如果成功地释放一个页面，并已发现系统中的空闲页面已经不再短缺，那么扫描可以结束了。否则继续扫描。

（5）如果页面不再是“脏”的，并且在某个address_space数据结构的队列中，这就是已经“清洗”了的页面，所以把它转移到所属区间的不活跃“干净”页面队列中。

（6）最后，如果不属于上诉的任何一种情况，那就无法处理的页面，所以把它退回活跃页面队列中。

完成了一趟扫描以后，还有根据系统中空闲页面是否短缺，以及调用参数的gfp_mask中的__GFP_IO标记位是否为1，来决定是否进行第二趟扫描。

```c++
[kswapd()>do_try_to_free_pages()>page_launder()]

    /*
     * If we don't have enough free pages, we loop back once
     * to queue the dirty pages for writeout. When we were called
     * by a user process (that /needs/ a free page) and we didn't
     * free anything yet, we wait synchronously on the writeout of
     * MAX_SYNC_LAUNDER pages.
     *
     * We also wake up bdflush, since bdflush should, under most
     * loads, flush out the dirty pages before we have to wait on
     * IO.
     */
    if (can_get_io_locks && !launder_loop && free_shortage()) {
          launder_loop = 1;
     /* If we cleaned pages, never do synchronous IO. */
     if (cleaned_pages)
          sync = 0;
     /* We only do a few "out of order" flushes. */
     maxlaunder = MAX_LAUNDER;
     /* Kflushd takes care of the rest. */
     wakeup_bdflush(0);
     goto dirty_page_rescan;
   }
  /* Return the number of pages moved to the inactive_clean list. */
     return cleaned_pages;
}
```

如果决定进行第二趟扫描，就转回到标号dirty_page_rescan处。注意这里launder_loop设成1，以后就不可能在回过去又扫描一次了。所以每次调用page_launder()最多是做两趟扫描。

回到do_try_to_free_pages()的代码中，经过page_launcher()以后，如果可分配的物理页面数量仍然不足，那就要进一步设法回收页面了。不过，也并不是单纯地从各个进程的用户空间所映射的物理页面中回收，而是从四个方面回收，这就是这里所调用三个函数shrink_dcache_memory() shrink_icache_memory() refill_inactive(），以及等一下会看到的kmem_cache_reap的意图。在打开文件的过程中要分配和使用代表着目录项的dentry数据结构，还有代表着文件索引节点的inode数据结构。这些数据结构在文件关闭以后并不立即释放，而是放到LRU队列中作为后备，以防在不久将来的文件操作又要用到。这样，经过一段时间以后，就有可能积累起大量dentry数据结构和inode数据结构，占用数量可观的物理页面。这时，就要通过shrink_dcache_memory()和shrink_icache_memory()适当加以回收，以维持这些数据结构与物理页面间“生态平衡”。另一方面，除此以外，内核在运行中也需要动态地分配使用很多数据结构，内核中对此采用了一种称为"slab"的管理机制。

```c++
[kswapd()>do_try_to_free_pages()>refill_inactive()]
     /*
      * We need to make the locks finer granularity, but right
      * now we need this so that we can do page allocations
      * without holding the kernel lock etc.
      *
      * We want to try to free "count" pages, and we want to
      * cluster them so that we get good swap-out behaviour.
      *
      * OTOH, if we're a user process (and not kswapd), we
      * really care about latency. In that case we don't try
      * to free too many pages.
      */
static int refill_inactive(unsigned int gfp_mask, int user)
{
    int priority, count, start_count, made_progress;

    count = inactive_shortage() + free_shortage();
    if (user)
        count = (1 << page_cluster);
    start_count = count;

    /* Always trim SLAB caches when memory gets low. */
    kmem_cache_reap(gfp_mask);

    priority = 6;
    do {
        made_progress = 0;

        if (current->need_resched) {
             __set_current_state(TASK_RUNNING);
             schedule();
        }

        while (refill_inactive_scan(priority, 1)) {
             made_progress = 1;
             if (--count <= 0)
                goto done;
        }
         /*
          * don't be too light against the d/i cache since
          * refill_inactive() almost never fail when there's
          * really plenty of memory free.
          */
        shrink_dcache_memory(priority, gfp_mask);
        shrink_icache_memory(priority, gfp_mask);

       /*
        * Then, try to page stuff out..
        */
        while (swap_out(priority, gfp_mask)) {
            made_progress = 1;
            if (--count <= 0)
                  goto done;
        }

    /*
     * If we either have enough free memory, or if
     * page_launder() will be able to make enough
     * free memory, then stop.
     */
     if (!inactive_shortage() || !free_shortage())
           goto done;

     /*
      * Only switch to a lower "priority" if we
      * didn't make any useful progress in the
      * last loop.
      */
      if (!made_progress)
          priority--;
    } while (priority >= 0);

    /* Always end on a refill_inactive.., may sleep... */
    while (refill_inactive_scan(0, 1)) {
         if (--count <= 0)
             goto done;
    }

done:
     return (count < start_count);
}
```

参数user是从kswapd传下来的，表示是否有函数在kswapd_done队列中等待执行，这个因素决定回收物理页面的过程是否可以慢慢来，所以对本次要回收的页面数量有影响。首先通过kmem_cache_reap()"收割"由slab机制管理的空闲物理页面，相对而言这是动作最小的。然后，就是一个do-while循环。循环从优先级最低的6级开始，逐步加大力度直到0级，结果或者达到了目标，回收的数量够了；或者在最高优先级时还是达不到目标，那也只好算了。

在循环中，每次开头都要检查一下当前进程的task_struct结构中的need_resched是否为1。如果是，就说明某个中断服务程序要求调度，所以调用schedule()让内核进行一次调度，但是在此之前把本进程的状态设置成TASK_RUNNING,表达要继续运行的意愿。task_struct结构中的need_resched是为强制调度而设置的，每当CPU结束了一次系统调用或者中断服务，从系统空间返回用户空间时就检查这个标志。可是，kswapd是个内核线程，永远不会“返回用户空间”，这样就有可能绕过这个机制而占住CPU不放，所以只能靠它“自律”，自己在可能需要较长时间的操作之前检查这个标记并调用schedule()。

那么，在循环中做些什么呢？主要是两件事。一件是通过refill_inactive_scan（）扫描活跃页面队列。试图从中找到可以转入不活跃状态的页面；另一件是通过swap_out()找出一个进程，然后扫描其映射表，从中找出可以转入不活跃状态的页面。此外，还要再试试用于dentry结构和inode结构的页面。

```c++
     /**
      * refill_inactive_scan - scan the active list and find pages to deactivate
      * @priority: the priority at which to scan
      * @oneshot: exit after deactivating one page
      *
      * This function will scan a portion of the active list to find
      * unused pages, those pages will then be moved to the inactive list.
      */
int refill_inactive_scan(unsigned int priority, int oneshot)
{
    struct list_head * page_lru;
    struct page * page;
    int maxscan, page_active = 0;
    int ret = 0;

    /* Take the lock while messing with the list... */
    spin_lock(&pagemap_lru_lock);
    maxscan = nr_active_pages >> priority;
    while (maxscan-- > 0 && (page_lru = active_list.prev) != &active_list) {
    page = list_entry(page_lru, struct page, lru);

    /* Wrong page on list?! (list corruption, should not happen) */
    if (!PageActive(page)) { 
      printk("VM: refill_inactive, wrong page on list.\n");
      list_del(page_lru);
      nr_active_pages--;
      continue;
    }

    /* Do aging on the pages. */
    if (PageTestandClearReferenced(page)) {
          age_page_up_nolock(page);
          page_active = 1;
    } else {
          age_page_down_ageonly(page);
    /*
     * Since we don't hold a reference on the page
     * ourselves, we have to do our test a bit more
     * strict then deactivate_page(). This is needed
     * since otherwise the system could hang shuffling
     * unfreeable pages from the active list to the
     * inactive_dirty list and back again...
     *
     * SUBTLE: we can have buffer pages with count 1.
     */
    if (page->age == 0 && page_count(page) <= (page->buffers ? 2 : 1)) {
            deactivate_page_nolock(page);
            page_active = 0;
    } else {
            page_active = 1;
    }
   }
    /*
     * If the page is still on the active list, move it
     * to the other end of the list. Otherwise it was
     * deactivated by age_page_down and we exit successfully.
     */
     if (page_active || PageActive(page)) {
            list_del(page_lru);
            list_add(page_lru, &active_list);
     } else {
           ret = 1;
           if (oneshot)
           break;
    }
 }
    spin_unlock(&pagemap_lru_lock);
    return ret;
}
```

就像对“脏”页面队列扫描一样，也是可通过局部量maxscan来控制扫描的页面数量。不过这里扫描的不一定是整个活跃页面队列，而是根据参数priority的值扫描其中一部分，只有在priority为0时才扫描这个队列。对于所扫描的页面，首先也要验证确实属于活跃页面。然后，根据页面是否收到了访问，决定增加或减少页面的寿命。如果减少页面以后达到了0，那就说明这个页面已经很长时间没有受到访问，因而已经耗尽了寿命。不过，光是耗尽了寿命还不足以把页面从活跃状态转入不活跃状态，还得看是否还有用户空间映射。如果页面并不用做文件系统的读/写缓冲，那么只要页面的使用计数大于1就说明还有用户空间映射，还不能转入不活跃状态，这样的页面在通过swap_out()扫描相应进程的映射表才能转入不活跃状态。对于还不能转入不活跃状态的页面，要将其从队列中的当前位置移到队列的尾部。反之，如果成功地将一个页面转入了不活跃状态，则根据参数oneshot的值决定是否继续扫描。一般来说，在活跃页面队列中的页面使用计数都大于1。而当swap_out()断开一个页面的映射而使其转入不活跃状态时，则已经将页面转入不活跃队列，因而不在这个队列中了。

```c++
[kswapd()>do_try_to_free_pages()>refill_inactive()>swap_out()]
297  /*
298   * Select the task with maximal swap_cnt and try to swap out a page.
299   * N.B. This function returns only 0 or 1.  Return values != 1 from
300   * the lower level routines result in continued processing.
301   */
302  #define SWAP_SHIFT 5
303  #define SWAP_MIN 8
304
305  static int swap_out(unsigned int priority, int gfp_mask)
306  {
307         int counter;
308         int __ret = 0;
309
310 /*
311  * We make one or two passes through the task list, indexed by
312  * assign = {0, 1}:
313  *   Pass 1: select the swappable task with maximal RSS that has
314  *         not yet been swapped out.
315  *   Pass 2: re-assign rss swap_cnt values, then select as above.
316  *
317  * With this approach, there's no need to remember the last task
318  * swapped out.  If the swap-out fails, we clear swap_cnt so the
319  * task won't be selected again until all others have been tried.
320  *
321  * Think of swap_cnt as a "shadow rss" - it tells us which process
322  * we want to page out (always try largest first).
323  */
324        counter = (nr_threads << SWAP_SHIFT) >> priority;
325        if (counter < 1)
326                counter = 1;
327
328        for (; counter >= 0; counter--) {
329            struct list_head *p;
330            unsigned long max_cnt = 0;
331            struct mm_struct *best = NULL;
332            int assign = 0;
333            int found_task = 0;
334 select:
335            spin_lock(&mmlist_lock);
336            p = init_mm.mmlist.next;
337            for (; p != &init_mm.mmlist; p = p->next) {
338                 struct mm_struct *mm = list_entry(p, struct mm_struct, mmlist);
339                 if (mm->rss <= 0)
340                      continue;
341                 found_task++;
342            /* Refresh swap_cnt? */
343                 if (assign == 1) {
344                      mm->swap_cnt = (mm->rss >> SWAP_SHIFT);
345                      if (mm->swap_cnt < SWAP_MIN)
346                      mm->swap_cnt = SWAP_MIN;
347                 }
348                 if (mm->swap_cnt > max_cnt) {
349                       max_cnt = mm->swap_cnt;
350                       best = mm;
351                 }
352           }
353
354           /* Make sure it doesn't disappear */
355           if (best)
356                 atomic_inc(&best->mm_users);
357           spin_unlock(&mmlist_lock);
358
359 /*
360  * We have dropped the tasklist_lock, but we
361  * know that "mm" still exists: we are running
362  * with the big kernel lock, and exit_mm()
363  * cannot race with us.
364  */
365          if (!best) {
366            if (!assign && found_task > 0) {
367                 assign = 1;
368                 goto select;
369            }
370           break;
371           } else {
372                 __ret = swap_out_mm(best, gfp_mask);
373                 mmput(best);
374                 break;
375           }
376       }
377       return __ret;
378 }
```

这个函数的主体是一个for循环，循环的次数取决于counter，而counter又是根据内核中进程（包括线程）的个数和调用swap_out()时优先级计算而来的。当优先级为0,时，counter就等于（nr_threads<<SWAP_SHIFT），即32xnr_threads,这里nr_threads为当前系统中进程的数量。这个数值决定了把页面换出去的“决心”有多大，即代码中外层循环的次数。参数gfp_mask中是一些控制信息。

在每次循环中，程序识图从所有进程中找到一个最合适的进程best。找到了就扫描这个进程的页面映射表，将符合条件的页面暂时断开对内存页面的映射，或进一步将页面转入不活跃状态，为把这些页面换出到交换设备上做好准备。

这里还应指出，这个函数虽然叫“swap_out”,但实际上只是为把一些页面换出到交换设备上做好准备，而并不一定是物理意义上的页面换出，所以在下面的叙述中所谓“换出”是广义的。那么，根据什么准则来找“最合适”的进程呢？可以说是“劫富济贫”与“轮流坐庄”相结合。每个进程都有其自身的虚存空间，空间中已经分配并建立了映射的页面构成一个集合。但是在任何一个给定的时刻，该集合中的每一个页面所对应的物理页面不一定都在内存中，在内存中的往往只是一个子集。这个子集称为“驻内存页面集合”，其大小称为rss。在存储管理结构mm_struct中有一个成分就是rss。

代码中的内存for循环表示从第二个进程开始扫描所有的进程。内核中所有的task_struct结构都是双向链表连城一个队列。而进程init_task是内核中的第一个进程，是所有其他进程的祖宗。只要内核还在运行，这个进程就“永远不落”。所以，从init_task.next_task始至init_task止，就是扫描除第一个进程外的所有进程。扫描的目的是从中找出mm->swap_cnt为最大的进程。每个mm_struct结构中的这个数值，是在把所有进程的页面资源时都处理一遍，从而每个mm_struct结构中这个数值都变成了0的时候设置好了的，反映了当时该进程占用内存页面的数量mm->rss。这就好像一次“人口普查”。随后，每次考察和处理了这个进程的一个页面，就将其mm->swap_out减1，直至最后变成0。所以，mm->rss反映了一个进程占用的内存页面数量，而mm->swap_out反映了该进程在一轮缓存内存页面的努力中尚未受到考察的页面数量。只要在这一轮中至少还有一个进程的页面尚未受到考察，就一定能找到一个“最佳对象”。一直到所有进程的mm->swap_cnt都变成了0，从而扫描下来竟找不到一个“best”时，在把这里的局部量assign置成1，在扫描一遍。这一次将每个进程当前的mm->rss拷贝到mm->swap_cnt中，然后在从最富有的进程开始。但是，所谓尚未受到考察的页面数量并不包括最近一次“人口普查”以后因页面异常而换入的页面，这些页面的数量要到下一次“人口普查”以后才会反映出来。就每个进程的角度而言，对内存页面的占用存在着两个方向上的运动：一个方面是因为页面异常而有更多的页面建立起或恢复起映射；另一个方面则是周期性地受到swap_out()的考察而被气短若干页面的映射。这两个运动的结合决定了一个人进程在特定时间内对内存页面的占用。页面的换出具体是由swap_out_mm()来完成的。

```C++
[kswapd()>do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()]
257 static int swap_out_mm(struct mm_struct * mm, int gfp_mask)
258 {
259       int result = 0;
260       unsigned long address;
261       struct vm_area_struct* vma;
262
263 /*
264  * Go through process' page directory.
265  */
266
267 /*
268  * Find the proper vm-area after freezing the vma chain
269  * and ptes.
270  */
271       spin_lock(&mm->page_table_lock);
272       address = mm->swap_address;
273       vma = find_vma(mm, address);
274       if (vma) {
275             if (address < vma->vm_start)
276             address = vma->vm_start;
277
278             for (;;) {
279                 result = swap_out_vma(mm, vma, address, gfp_mask);
280                 if (result)
281                      goto out_unlock;
282                 vma = vma->vm_next;
283                 if (!vma)
284                      break;
285                 address = vma->vm_start;
286            }
287       }
288 /* Reset to 0 when we reach the end of address space */
289       mm->swap_address = 0;
290       mm->swap_cnt = 0;
291
292 out_unlock:
293       spin_unlock(&mm->page_table_lock);
294       return result;
295  }
```

首先，mm->swap_address表示在执行这个过程中要接着考察的页面地址。最初时该地址为0，到所有的页面都已经考察了一遍的时候就又清成0。程序在一个for循环中根据当前的这个地址找到其所在的虚存区域vma，然后就调用swap_out_vma（）试图换出一个页面。如果成功，这一次任务就完成了。否则就试下一个虚存区域。就这样一层一层地往下调用，经过swap_out_vma,swap_out_pgd,swap_out_pmd,一直到try_to_swap_out,试图换出由一个表面表项pte所指向的内存页面。

```c++
[kswapd()>do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()]
27  /*
28   * The swap-out functions return 1 if they successfully
29   * threw something out, and we got a free page. It returns
30   * zero if it couldn't do anything, and any other value
31   * indicates it decreased rss, but the page was shared.
32   *
33   * NOTE! If it sleeps, it *must* return 1 to make sure we
34   * don't continue with the swap-out. Otherwise we may be
35   * using a process that no longer actually exists (it might
36   * have died while we slept).
37   */
38  static int try_to_swap_out(struct mm_struct * mm, struct vm_area_struct* vma, unsigned long address,
pte_t * page_table, int gfp_mask)
39  {
40        pte_t pte;
41        swp_entry_t entry;
42        struct page * page;
43        int onlist;
44
45        pte = *page_table;
46        if (!pte_present(pte))
47             goto out_failed;
48        page = pte_page(pte);
49        if ((!VALID_PAGE(page)) || PageReserved(page))
50             goto out_failed;
51
52        if (!mm->swap_cnt)
53             return 1;
54
55         mm->swap_cnt--;
56
```

首先要说明，参数page_table石基上指向一个页面表项，而不是页面表，参数名page_table有些误导。把这个表项的内容赋给变量pte以后，就通过pte_present来测试改表项所指的物理页面是否在内存中，如果不在内存中旧转向out_failed，本次操作就失败了：

```c++
106 out_failed:
107       return 0;
```

当try_to_swap_out返回0时，其上一层的程序就会跳过这个页面，而试着换出同一个页面表中映射的下一个页面。如果一个页面表已经穷尽，就再往上退一层试下一个页面表。反之，如果物理页面确在内存中，就通过pte_pages()将页面表项的内容换算成指向该物理内存页面page结构的指针。由于所有page结构都在mem_map数组中，所以page-mem_map就是该页面的序号。要是这个序号大于最大的物理内存页面序号max_mapnr,那就不是一个有效的物理页面，这种情况通常是因为物理页面在外部设备上，所以也跳过这一项。

```C++
118  #define VALID_PAGE(page) ((page - mem_map) < max_mapnr)
```

此外，对于保留在内存中不允许换出的物理页面也要跳过。跳过了这两种特殊情况，就要具体地考察一个页面了，所以将mm->swap_cnt减1.继续往下看try_to_swap_out代码：

```c++
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()]
57        onlist = PageActive(page);
58 /* Don't look at this pte if it's been accessed recently. */
59        if (ptep_test_and_clear_young(page_table)) {
60             age_page_up(page);
61             goto out_failed;
62        }
63        if (!onlist)
64        /* The page is still mapped, so it can't be freeable... */
65             age_page_down_ageonly(page);
66
67 /*
68  * If the page is in active use by us, or if the page
69  * is in active use by others, don't unmap it or
70  * (worse) start unneeded IO.
71  */
72        if (page->age > 0)
73             goto out_failed;
74
```

内存页面的page结构中，字段flags中的各种标记位反应着页面的当前状态，其中的PG_active标记位表示当前这个页面是否“活跃”，即是否仍在active_list队列中：

```c++
230  #define PageActive(page) test_bit(PG_active, &(page)->flags)
```

一个可交换的物理页面一定在某个LRU队列中，不在active_list队列中就说明一定在inactive_dirty_list中或某个inactive_clean_list中，等一下就要使用测试结果。

一个映射中的物理页面是否应该换出，取决于这个页面最近是否受到了访问。这是通过inline函数ptep_test_and_clear_young()测试的：

```c++
285  static inline  int ptep_test_and_clear_young(pte_t *ptep) { return
     test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep); }
```

如前所述，页面表项中有个PAGE_ACCESSED标记位。当i386CPU的内存映射机制在通过一个页面表项将一个虚拟地址映射成一个物理地址，进而访问这个物理地址时，就会自动将PAGE_ACCESSED标记位设成1.所以，如果pte_young（）返回1，就表示从上一次对同一个页面表项调用try_to_swap_out()至今，该页面至少已经被访问过一次，所以说页面还“年轻”。一般而言，最近受到访问就预示着在不久的将来也会受到访问，所以不宜将其换出。取的了此项信息以后，就将页面表项的PAGE_ACCESSED标记位清成0，再把它协会页面表项，为下一次再来测试这个标记位做好准备。

如果页面还“年轻”，那就肯定不是要加以换出的对象，所以也要转到out_failed。不过，在转到out_failed上前还要做一点事情：如果页面还活跃，就要通过SetPageReferenced()将page数据结构中PG_referenced标记位置成1.也就是说，将页面表项中表示受到访问的信息转移至页面的数据结构中。而要是页面不在活跃页面队列中，则通过age_page_up增加页面就可以留下来“以观后效”的时间，因为毕竟这个页面最近以受到访问。

```C++
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()>age_page_up()]
125  void age_page_up(struct page * page)
126  {
127 /*
128  * We're dealing with an inactive page, move the page
129  * to the active list.
130  */
131       if (!page->age)
132            activate_page(page);
133
134 /* The actual page aging bit */
135       page->age += PAGE_AGE_ADV;
136       if (page->age > PAGE_AGE_MAX)
137            page->age = PAGE_AGE_MAX;
138  }

```

转到out_failed以后，就在那里返回0，让更高层的程序跳过这个页面。这样，到下一轮又轮到这个进程和这个页面时，如果同一个页面表项pte中的PAGE_ACCESSED标记位任然为0，那就表示不再“年轻”了。既然这个页面是有映射的，怎么又会在不活跃页面队列中呢？以后读者就会在do_swap_page()中看到，当因页面异常而恢复一个不活跃页间的映射时，并不立即把它转入活跃页面队列，而把这项工作留给前面看到的page_launder(),让其在系统比较空闲时再来处理，所以这样的页面有可能不在活跃队列中。

如果页面已不“年轻”，那就要进一步观察了。当然，也不能因为这个页面在过去一周期中未受到访问就马上把它换出去，还要给它一个“留职察看”的机会。察看多久呢？那就是page->age的值，即页面的寿命。如果页面不在活跃队列中则还要先通过age_page_down_ageonly()减少其寿命：

```c++
103  /*
104   * We use this (minimal) function in the case where we
105   * know we can't deactivate the page (yet).
106   */
107  void age_page_down_ageonly(struct page * page)
108  {
109            page->age /= 2;
110  }
```

只要page->age尚未达到0，就还不能将此页面换出，所以也要转到out_failed。经过上面这些筛选，这个页面原则上已经是可以换出的对象了。

```c++
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()>swap_o
ut_pmd()>try_to_swap_out()]
75        if (TryLockPage(page))
76             goto out_failed;
77
78 /* From this point on, the odds are that we're going to
79  * nuke this pte, so read and clear the pte.  This hook
80  * is needed on CPUs which update the accessed and dirty
81  * bits in hardware.
82  */
83        pte = ptep_get_and_clear(page_table);
84        flush_tlb_page(vma, address);
85
86 /*
87  * Is the page already in the swap cache? If so, then
88  * we can just drop our reference to it without doing
89  * any IO - it's already up-to-date on disk.
90  *
91  * Return 0, as we didn't actually free any real
92  * memory, and we should just continue our scan.
93  */
94        if (PageSwapCache(page)) {
95             entry.val = page->index;
96             if (pte_dirty(pte))
97                  set_page_dirty(page);
98         set_swap_pte:
99             swap_duplicate(entry);
100            set_pte(page_table, swp_entry_to_pte(entry));
101        drop_pte:
102            UnlockPage(page);
103            mm->rss--;
104            deactivate_page(page);
105            page_cache_release(page);
106       out_failed:
107            return 0;
108 }
```

对page数据结构的操作涉及需要互锁，或者说独占的条件下进行的操作，所以这里通过TryLockPage（）将page数据结构锁住。

```c++
183  #define TryLockPage(page)  test_and_set_bit(PG_locked, &(page)->flags)
```

如果返回值为1，即表示PG_locked标记位原来就已经是1，已经被别的进程先锁住了，此时就不能继续处理这个page数据结构，而有只好失败返回。加锁成功以后，就可以根据页面的不同情况组换出准备了。首先通过ptep_get_and_clear()再读一次页面表项的内容，并把表项的内容清成0，暂时撤销该页面的映射。前面已经读了一次页面表项的内容，为什么现在还要再读一次，而不仅仅是把表项内容清0呢，在多处理器系统中，目标进程有可能正在另一个CPU上运行，所以其映射表项的内容可能已经改变。

如果页面的page数据结构已经在为页面换入/换出而设置的队列中，即数据结构swapper_space内的队列中，那么页面的内容已经在交换设备上，只要把樱色暂时断开，表示目标进程已经同意释放这个页面，就可以了。不过，为页面换入/换出而设置的队列也分“干净”和“脏”两个，所以如果页面已经受过范文就要通过set_page_dirty()将其转入“脏”页面队列。宏操作PageSwapCache()的定义为：

```c++
217  #define PageSwapCache(page) test_bit(PG_swap_cache, &(page)->flags)
```

标记位PG_swap_cache为1表示page结构在swapper_space队列中，也说明相应的页面是个普通的换入/换出页面。此时page结构中的index字段是一个32位的索引项swap_entry_t，实际上是指向页面在交换设备上的映像的指引。函数swap_duplicate()作用，一者是要对索引项的内容作一些检验，二者是要递增相应盘上页面的共享技术：

```c++
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()>swap_duplicate()]
820  /*
821   * Verify that a swap entry is valid and increment its swap map count.
822   * Kernel_lock is held, which guarantees existance of swap device.
823   *
824   * Note: if swap_map[] reaches SWAP_MAP_MAX the entries are treated as
825   * "permanent", but will be reclaimed by the next swapoff.
826   */
827  int swap_duplicate(swp_entry_t entry)
828  {
829       struct swap_info_struct * p;
830       unsigned long offset, type;
831       int result = 0;
832
833 /* Swap entry 0 is illegal */
834       if (!entry.val)
835            goto out;
836       type = SWP_TYPE(entry);
837       if (type >= nr_swapfiles)
838            goto bad_file;
839       p = type + swap_info;
840       offset = SWP_OFFSET(entry);
841       if (offset >= p->max)
842            goto bad_offset;
843       if (!p->swap_map[offset])
844            goto bad_unused;
845 /*
846  * Entry is valid, so increment the map count.
847  */
848       swap_device_lock(p);
849       if (p->swap_map[offset] < SWAP_MAP_MAX)
850            p->swap_map[offset]++;
851       else {
852            static int overflow = 0;
853            if (overflow++ < 5)
854            printk("VM: swap entry overflow\n");
855            p->swap_map[offset] = SWAP_MAP_MAX;
856       }
857       swap_device_unlock(p);
858       result = 1;
859  out:
860       return result;
861
862  bad_file:
863       printk("Bad swap file entry %08lx\n", entry.val);
864       goto out;
865  bad_offset:
866       printk("Bad swap offset entry %08lx\n", entry.val);
867       goto out;
868  bad_unused:
869       printk("Unused swap offset entry in swap_dup %08lx\n", entry.val);
870       goto out;
871  }
```

```c++
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()>deactivate_page()]
189  void deactivate_page(struct page * page)
190  {
191       spin_lock(&pagemap_lru_lock);
192       deactivate_page_nolock(page);
193       spin_unlock(&pagemap_lru_lock);
194  }
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()>deactivate_page()>deactivate_page_nolock()]
154  /**
155   * (de)activate_page - move pages from/to active and inactive lists
156   * @page: the page we want to move
157   * @nolock - are we already holding the pagemap_lru_lock?
158   *
159   * Deactivate_page will move an active page to the right
160   * inactive list, while activate_page will move a page back
161   * from one of the inactive lists to the active list. If
162   * called on a page which is not on any of the lists, the
163   * page is left alone.
164   */
165  void deactivate_page_nolock(struct page * page)
166  {
167 /*
168  * One for the cache, one for the extra reference the
169  * caller has and (maybe) one for the buffers.
170  *
171  * This isn't perfect, but works for just about everything.
172  * Besides, as long as we don't move unfreeable pages to the
173  * inactive_clean list it doesn't need to be perfect...
174  */
175       int maxcount = (page->buffers ? 3 : 2);
176       page->age = 0;
177       ClearPageReferenced(page);
178
179 /*
180  * Don't touch it if it's not on the active list.
181  * (some pages aren't on any list at all)
182  */
183       if (PageActive(page) && page_count(page) <= maxcount && !page_ramdisk(page)) {
184            del_page_from_active_list(page);
185            add_page_to_inactive_dirty_list(page);
186       }
187  }
```

在物理页面的page结构中有个计数器count,空闲页面的这个计数为0，在分配页面时将其设为1，伺候每当页面增加一个“用户”，如建立或恢复一个映射，就使count加1。这样这个计算器的值为2，就说明刚断开的映射已经是该物理页面的最后一个映射。既然最后的映射已经断开，这页面当然是不活跃的了。所以把小于等于2作为一个判断的标准，就是这里的maxcount。这里还要考虑一种特殊情况，就是当这个页面是通过mmap映射到普通文件，而这个文件已经被打开，按常规的文件操作访问的，因此这个页面又同时用作读/写文件的缓冲。此时页面划分成若干缓冲区，其page结构的指针buffers指向一个buffer_head数据结构队列，而这个队列则成了该页面的另一个“用户”。所以，当page->buffers非0时，maxcount为3说明刚断开的映射时该内存的最后一个映射。此外，内存页面有可能用作ramdisk，即以一部分内存物理空间来模拟硬盘，这样的页面永远不会变成活跃。这样，判断的准则一共有三条，只有在满足了这三条准则时才真的可以将页面入不活跃队列。多数有用户空间映射的内存页面只有一个映射，此时就转入了不活跃状态。同时，从代码中也可看出，对不在活跃队列中的页面再次调用一次deactivate_page_nolock()并无坏处。

将一个活跃的页面编程不活跃时，要把该页面的page结构从活跃页面的LRU队列active_list中转入一个不活跃队列中。可以系统中有两个不活跃页面队列。一种“dirty”，即可能最近已被写过，因而跟交换设备上的页面不一致“脏”页面队列，这样的页面不能马上被那来分配，因为还需要把它写出去才能把它“洗净”。另一种是“clean”，即肯定跟交换设备上的页面一致的“干净”页面队列，这样的页面原则上已可作为空闲页面分配，只是因为页面中的内容可能有用，因而再予以保存一段时间
。不活跃“脏”页面队列只有一个，那就是inactive_dirty_list；而不活跃“干净”页面队列则有很多，每个页面管理区中都有个inactive_clean_list队列。那么，当一个原来活跃的页面变成不活跃时，应该把它转移到哪一个队列中呢？第一步总是把它转入“脏”页面队列。将一个page结构从活跃队列脱链是由宏操作del_page_from_active_list（）完成：

```c++
234  #define del_page_from_active_list(page) { \
235       list_del(&(page)->lru); \
236       ClearPageActive(page); \
237       nr_active_pages--; \
238       DEBUG_ADD_PAGE \
239       ZERO_PAGE_BUG \
240  }

217  #define add_page_to_inactive_dirty_list(page) { \
218       DEBUG_ADD_PAGE \
219       ZERO_PAGE_BUG \
220       SetPageInactiveDirty(page); \
221       list_add(&(page)->lru, &inactive_dirty_list); \
222       nr_inactive_dirty_pages++; \
223       page->zone->inactive_dirty_pages++; \
224  }
```

这里的ClearPageActive()和SetPageInactiveDirty()分别将page结构中的PG_active标记位清成0或将PG_inactive_dirty标记位设成1。注意在这个过程中page结构中使用的计数未改变。

又回到try_to_swap_out（）的代码中，既然断开了对一个内存页面的映射，就要递减对这个页面的使用计数，这是由宏操作page_cache_release(),实际上是由free_pages（）完成

```c++
==================== include/linux/pagemap.h 34 34 ====================
34  #define page_cache_release(x) __free_page(x)
==================== include/linux/mm.h 379 379 ====================
379  #define __free_page(page) __free_pages((page), 0)
==================== mm/page_alloc.c 549 553 ====================
549  void __free_pages(struct page *page, unsigned long order)
550  {
551 if (!PageReserved(page) && put_page_testzero(page))
552 __free_pages_ok(page, order);
553  }
==================== include/linux/mm.h 152 152 ====================
152  #define put_page_testzero(p) atomic_dec_and_test(&(p)->count)
 ```

这个函数通过put_page_testzero(),将page结构中count的值减1，然后测试是否达到了0，如果达到了0就通过free_pages_ok（）将该页面释放。在这里，由于页面还在不活跃页面队列中尚未释放，至少还有这么一个引用，所以不会达到0。至此，对这个页面处理就完成了，于是又到了标号out_failed处而返回0。为什么又是到达
out_failed处呢？其实，try_to_swap_out仅在一种情况下才返回1，那就是当mm->swap_out达到了0的时候。正是这样，才使swap_out_mm（）能够一次考察和处理一个进程的所有页面。

要是页面的page结构不在swapper_space的队列中呢？这说明尚未为该页面在交换设备上建立起映射，或者页面来自一个文件。读者可以回顾一下，在因页面无映射而发生缺页异常时，具体的处理取决于页面所在的区间是否提供了一个vm_operation_struct数据结构，并且通过这个数据结构中的函数指针nopage提供了特定的操作。如果提供了nopage操作，就说明该区间的页面来自一个文件（而不是交换设备），此时根据虚存地址时计算出在文件中的页面位置。否则就是普通的页面，但尚未建立相应的盘上页面，此时先把它映射到空白页面，以后需要写的是否才为之另行分配一个页面。


```C++
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()]
110 /*
111  * Is it a clean page? Then it must be recoverable
112  * by just paging it in again, and we can just drop
113  * it..
114  *
115  * However, this won't actually free any real
116  * memory, as the page will just be in the page cache
117  * somewhere, and as such we should just continue
118  * our scan.
119  *
120  * Basically, this just makes it possible for us to do
121  * some real work in the future in "refill_inactive()".
122  */
123       flush_cache_page(vma, address);
124       if (!pte_dirty(pte))
125            goto drop_pte;
126
127 /*
128  * Ok, it's really dirty. That means that
129  * we should either create a new swap cache
130  * entry for it, or we should write it back
131  * to its own backing store.
132  */
133       if (page->mapping) {
134            set_page_dirty(page);
135            goto drop_pte;
136       }
137
138 /*
139  * This is a dirty, swappable page.  First of all,
140  * get a suitable swap entry for it, and make sure
141  * we have the swap cache set up to associate the
142  * page with that swap entry.
143  */
144       entry = get_swap_page();
145       if (!entry.val)
146            goto out_unlock_restore; /* No swap space left */
147
148 /* Add it to the swap cache and mark it dirty */
149       add_to_swap_cache(page, entry);
150       set_page_dirty(page);
151       goto set_swap_pte;
152
153 out_unlock_restore:
154       set_pte(page_table, pte);
155       UnlockPage(page);
156       return 0;
157  }
```

这里的pte_dirty()是一个inline函数，在页面表项中有一个“D”标记位（PAGE_DIRTY）,如果CPU对表项所指的内存页面进行了写操作，就自动把该标志位设置成1，表示该内存页面已经“脏”了。如果此标记位为0，就表示相应内存页面尚未被写过。对这样的页面，如果很久没有受到访问，就可以吧映射解除（而不是暂时断开）。这是因为；如果页面的内容为空白，那么以后需要时可以再来建立映射；或者，如果页面来自通过mmap建立起的文件映射，则在需要时可以根据虚拟地址计算出页面在文件中的位置。所以，这是转到前面的标号drop_pte处。注意在这种情况下前面的deactivate_page实际上不起作用，特别是页面表项清0，而page_cache_release则只是递减对空白页面的引用计数。

如果所考察的页面是来自通过mmap()建立起来的文件映射，则其page结构中的指针mmaping指向相应的address_space数据结构。对于这样的页面，如果决定解除映射，而页面表项中PAGE_DIRTY标记位为1，就要在转到drop_pte处之前，先把page结构中的PG_dirty标记位设成1，并把页面转移到改文件映射的“脏”页面队列中。

```c++
==================== include/linux/mm.h 187 191 ====================
[kswapd()>_do_try_to_free_pages()>refill_inactive()>swap_out()>swap_out_mm()>swap_out_vma()>swap_out_pgd()
>swap_out_pmd()>try_to_swap_out()>set_page_dirty()]
187  static inline void set_page_dirty(struct page * page)
188  {
189       if (!test_and_set_bit(PG_dirty, &page->flags))
190            __set_page_dirty(page);
191  }
==================== mm/filemap.c 134 147 ====================
134  /*
135   * Add a page to the dirty page list.
136   */
137  void __set_page_dirty(struct page *page)
138  {
139       struct address_space *mapping = page->mapping;
140
141       spin_lock(&pagecache_lock);
142       list_del(&page->list);
143       list_add(&page->list, &mapping->dirty_pages);
144       spin_unlock(&pagecache_lock);
145
146       mark_inode_dirty_pages(mapping->host);
147  }
```

在往下看try_to_swap_out的代码。当程序执行到这里时，所考察的页面必然是个很久没有受到访问，又不在swapper_space的换入/换出队列中，也不属于文件映射，但却是个受到过写访问的“脏”页面。对于这样的页面必须要为止分配一个盘上页面，并将其内容写到盘上页面中去。首先通过get_swap_page()分配一个盘上页面，这里宏操作：

```c++
==================== include/linux/swap.h 150 150 ====================
150  #define get_swap_page() __get_swap_page(1)
```

