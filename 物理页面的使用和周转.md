# Memory-Management

交换设备(通常是磁盘，也可以是普通文件)的每个物理页面也要在内存中有个相应的数据结构(或者说“户口”)，不过那些要简单得多，实际上只是一个计数，表示该页面是否已被分配使用，以及有几个用户在共享这个页面。对盘上页面的管理是按文件或磁盘设备来进行的。内核中定义一个swap_info_struct数据结构，用以描述和管理用于页面交换的文件和设备。它的定义包含在include/linux/swap.h中：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410a.jpg)

其中的指针swap_map指向一个数组，该数组中的每一个无符号短整数即代表磁盘上的一个物理页面，而数组的下标则决定了该页面在磁盘或文件上的位置。数组的大小取决于pages，他表示该页面交换设备或文件的大小。设备上（或文件中，设备也是一种文件，下同）的第一个页面，也即swap_map[0]所代表的那个页面是不用于页面交换的，它包含了该设备或文件自身的一些信息以及一个表明那些页面可供使用的位图。这些信息最初是在把改设备格式化成页面交换区时设置的。根据不同的页面交换区格式，还有一些其他页面也不供页面交换使用。这些页面都集中在开头和结尾两个地方，所以swap_info_struct结构中的lowest_bit和highest_bit就说明文件中从什么地方开始到什么地方为止是供页面交换使用的。另一个字段max则表示该设备或文件中最大的页面号，也就是设备或文件的物理大小。

由于存储介质是转动的磁盘，将地址连续的也页面存储在连续的磁盘扇区中不见得是最有效的方法，所以在分配盘上页面空间时尽可能按集群(cluster)方式进行，而字段cluster_next和cluster_nr就是为此而设置的。

Linux内核允许使用多个页面交换设备（或文件），所以在内核中建立了一个swap_info_struct结构的阵列（数组）swap_info:

```c
   struct swap_info_struct swap_info[MAX_SWAPFILES];
``` 

同时，还设立一个队列swap_list,将各个可以分配物理页面的磁盘设备或文件的swap_info_struct结构按优先级高低链接在一起。

```c
    struct swap_list_t swap_list = {-1, -1};
    struct swap_list_t {
           int head;
           int next;
     }
``` 

开始时队列为空，所以head和next均为-1。当系统调用swap_on()指定一个文件用于页面交换时，就将该文件的swap_info_struct结构链入队列中。

就像通过pte_t数据结构（页面表项）将物理内存页面和虚存页面建立联系一样，盘上页面也有这么一个swap_entry_t数据结构：

```c
   typedef struct {
           unsigned long val;
  } swp_entry_t;
```

可见，一个swap_entry_t结构实际上是一个32位无符号整数。但是，这个32位整数实际上分成三个部分：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410b.jpg)

这里offset表示页面在一个磁盘设备或文件中的位置，也就是文件中的逻辑页面号；而type则是指该页面在哪一个文件中，是个序号。这个位段的命名很容易引起误解，估计这是从pte_t结构中过来的。

当一个页面在内存中是，页面表中的表项pte_t的最低位P标志为1，表示页面在内存中，而其余各位指明物理内存页面的地址及页面的属性。而当一个页面在磁盘上时，则相应的页面表项不在指向一个物理内存页面，而是变成一个swap_entry_t"表项"，指示着这个页面的去向。由于此时其最低位为0，表示页面不在内存，所以CPU中的MMU
单元对其各位都忽略不顾，而留系统软件自己来加以解释。在linux内核中，就用它来唯一地确定一个页面在盘上的位置，包括在哪一个文件或设备，以及页面在此文件中的相对位置。

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410c.jpg)
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410d.jpg)

先介绍一下一个磁盘页面的函数swap_free()。通过这个函数的阅读，可以加深理解。如果entry.val为0，就显然不需要做任何事，因为在任何页面交换设备或文件中页面0是不用于页面交换的。接着，如前所述，SWAP_TYPE所返回的实际上是页面交换设备的序号，即其swap_info_struct结构在swap_info[]数组中的下标。所以156行以此为下标从swap_info[]中取的具体文件的swap_info_struct结构。

如前所述，offset是页面在文件中的位置，当然不能大于文件本身所提供的最大值。而p->swap_map[offset]是该页面的分配（和使用）计数。如为0就表明尚未分配。同时，分配计数也不应该大于SWAP_MAP_MAX。函数的调用参数count表示有几个使用者释放该页面，所以从计数中减去count。当计数达到0时，这个页面就真正变成空闲了。此时，如果页面落在当前可供分配的范围之外，就要相应地调整这个范围的边界lowest_bit或highest_bit，同时，可供分配的盘上页面的数量nr_swap_pages也增加了。值得注意的是，释放磁盘页面的实际操作实际上并不涉及磁盘操作，而只是在内存中“账面”上的操作，表示磁盘上那个页面的内容已经作废。所以，花费的代价是极小的。

知道了内核怎么管理内存页面和盘上页面以后，就可以来看看内存页面的周转了。当一个内存页面空闲，也就是留在某一个空闲页面管理区的空闲队列中，其page结构中的计数count为0，而在分配页面时将其设置成1.这是在函数rmqueue（）中通过set_page_count（）设置的。

所谓内存页面的周转有两方面的意思。其一是页面的分配，使用和回收，并不一定涉及页面的盘区交换。其二才是盘区交换，而交换的目的最终也是页面的回收。并非所有的内存页面都是可以交换出去的。事实上，只有映射到用户空间的页面才会被换出，而内核，即系统空间的页面则不在此列。这里说明一下，在内核中可以访问所有物理页面，换言之所有物理页面在系统空间都是有映射的。所谓“用户空间的页面”，是指在至少一个进程的用户空间中有映射的页面，反之则为内核使用的页面。
按页面的内容和性质，用户空间的页面有下面几种：
* 普通的用户空间页面，包括进程的代码段，数据段，堆栈段，以及动态分配的“存储堆”。其中有些页面从用户程序即进程的角度是静态的，但是从系统的角度看仍是动态分配的。
* 通过系统调用mmap（）映射到用户空间的已打开的文件的内容。
* 进程间的共享内存区。

这些页面既涉及分配，使用和回收，也涉及页面的换出/换入。

凡是映射到系统空间的页面都不会被换出，但还是可以按使用和周转的不同而大致分成几类。首先，内核代码和内核中全局量所占的内存页面既不需要经过分配也不会被释放，这部分空间是静态的。（相比之下，进程的代码段和全局量都在用户都再用户空间，所占的内存页面都是动态的，使用前要经过分配，最后都会被释放，并且中途可能被换出而回收后另行分配）

除此之外，内核中使用的内存页面也要经过动态分配，但永远要保留在内存，不会被交换出去。此类常驻内存内存的页面根据其内容的性质可以分成两类。
一类是一旦使用完毕便无保留的价值，所以立即便可释放，回收。这类页面的周转很简单，就是空闲->(分配)->使用->(释放)->空闲。这种用途的内核页面大致有这样一些：
* 内核中通过kmalloc()或vmalloc()分配，用作其某些临时性使用和为管理目的而设的数据结构，如vma_area_struct数据结构等等。这些数据结构一旦使用完毕便无保留价值，所以立即便可释放，不过由于一个页面的往往有多个不同种数据结构，所以要到这个页面都空闲时才能把页面释放。
* 内核中通过alloc_page()分配，用作某些临时性使用和为管理目的的内存页面，如某个进程的系统堆栈所在的两个页面，以及从系统空间复制参数时使用的页面等等。这些页面也是一旦使用完毕便无保留的价值，所以立即释放。

另一类是虽然使用完毕了，但是其内容仍有保存的价值。只要条件允许，把这些页面“养起来”也许可以提高以后的操作效率。这类页面（或数据结构）在“释放”之后要放入一个LRU队列，经过一段时间的缓存让其“老化”，如果在此期间忽然又要用到其内容了，便直接将页面连内容分配给“用户”；或则便继续老化，直到条件不再允许时才回收。这种用途的内核页面大致上有下面这些：
* 在文件系统操作中用来缓冲存储一些文件目录结构dentry的空间。
* 在文件系统操作中用来缓冲存储一些inode结构的空间。
* 用于文件系统读/写操作的缓存区。

这些页面的内容是从文件系统中直接读入或经过综合取得到，释放后立即回收另作他用也并无不可，但是那样以后要用时就又要付出代价了。
相比之下，页面交换是最复杂的。显然，最简单的页面交换策略就是：每当缺页异常时便分配一个内存页面，并把在磁盘上的页面读入到分配得到的内存页面中。如果没有空闲页面可供分配，就设法将一个或几个内存页面换出到磁盘上，从而腾出一些内存页面来。但是，这种完全消极的页面交换策略有个缺点，就是页面的交换总是“临阵磨枪”，发生在系统忙碌的时候而没有调用的余地。比较积极的办法是定期地，最好是在系统相对空闲时，挑选一些页面先换出腾出一些内存页面，从而在系统中维持一定的空闲页面供应量，是的在缺页中断发生时总是有空闲内存页面可供分配。至于挑选的准则，一般都是LRU，既挑选“最近最少用到”的页面。但是，这种积极的页面交换策略实行起来也有问题，因为实际上不存在一种方法可以准确地预测页面的访问。所以，完全有可能发生这样的现象，就是一个页面已经好久没有受到访问了，但是刚把他换出到磁盘上，却又有访问了，于是只好又赶快把它换进来。在最坏的情况下，有可能真个系统的处理能力被这样的换入/换出所饱和，而实际上根本不能进行有效的运算和操作。有人把这种现象称为页面的“抖动”。

物理内存页面换入/换出的周转要点如下：
* 空闲。页面的page数据结构通过其队列头结构list链入到某个页面管理区（zone）的空闲区队列free_area。页面的使用计数count为0。
* 分配。通过函数alloc_pages()或get_free_page()从某个空闲队列中分配内存页面，并将所分配页面的使用计数count置为1，其page数据结构的队列头list结构变成空闲。
* 活跃状态。页面的page数据结构通过其队列头结构lru链入活跃页面队列active_list，并且至少一个进程的（用户空间）页面表项指向该页面。每当为页面建立或恢复映射时，都使用页面的计数count加1。
* 不活跃状态(脏)。页面的page数据结构通过其队列结构lru链入不活跃“脏”页面队列inactive_dirty_list,但是原则上不在有任何进程的页表项指向改页面。每当断开页面的映射都使页面的使用计数count减1。
* 不活跃状态(干净)。页面的page数据结构通过其队列头结构lru链入某个不活跃“干净”页面队列，每个页面管理区都有一个不活跃“干净”页面队列inactive_clean_list。
* 如果在转入不活跃状态之后的一段时间内页面受到访问，则又转入活跃状态并恢复映射。
* 当有需要时，就从“干净”页面队列中回收页面，或退回到空闲队列中，或直接另行分配。
 
