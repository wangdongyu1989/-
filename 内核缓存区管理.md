
## Memory-Management

可想而知，内核在运行中常常需要使用一些缓冲区。例如，当要建立一个新的进程时就要增加一个task_struct结构，而当进程撤销时就要释放本进程的task结构。这些小块存储空间的使用并不局限某一个子进程，否则就可以作为这个子程序的局部变量而使用堆栈空间了。另外，这些小块存储空间又是动态变化的，不像用于页面管理的page结构那样，有多大的内存就有多少个page结构，构成一个静态的阵列。由于事先根本分无法预测运行中各种不同数据结构对缓存区的需求，不适合为每一种可能用到的数据结构建立一个“缓冲池”，因为那样的话很可能会出现有些缓存池已经用尽而有些缓冲池中却有大量缓冲区的局面。因此，只能采用更具有全局性的方法。

那么，用什么样的方法呢，如果采用像用户空间的malloc那样的动态分配办法，从一个统一的存储空间“堆”（heap）中，需要多少就切多大一块，不用就归还，则有几个缺点需要考虑改进：

* 久而久之，会使存储堆“碎片化”，以至虽然存储堆中空闲空间的总量足够大，却无法分配所需大小的连续空间。为此，一般都采用按2的次幂的大小分配空间，以缓解碎片化。

* 每次分配得到所需大小的缓冲区以后，都要进行初始化。内核中频繁地使用一些数据结构，这些数据结构中相当一部分成分需要某些特殊的初始化（例如队列头部等）而并非简单地清成0。如果释放的数据结构可以在下次分配时“重用”而无需初始化，那就可以提高内核的效率。

* 缓冲区的组织和管理是密切相关。在有高速缓冲区的情况下，这些缓冲区的组织和管理方式直接影响到高速缓存中的命中率，进而影响到运行时的效率。试想，假定我们运用最先符合(first fit)的方法，从一个由存储空间片段构成的队列中分配缓冲区。在这样的过程中，当一个片段不能满足要求而顺着指针往下看下一个片段的数据结构时，如果该数据结构每次都在不同的片段中，因而每次都不能命中，而要从内存转入到高速缓存，那么可想而知，其效率显然要打折扣了。

* 不适合多处理器共用内存的情况。

在slab方法中，每种重要的数据结构都有自己专用的缓冲区队列，每种数据结构都有相应的“构造”和“拆除”函数。同时，还借用面向对象程序设计中的名词，不再称“结构”而称为“对象”。缓冲区队列中的各个对象在建立时用其“构造”函数进行初始化，所以一经分配立即就能使用，而在释放时则恢复成原状。例如，对于其中的队列头成分来说，当将其从队列中摘除时自然就恢复成了原状。每个队列中“对象”的个数是动态变化的，不够时可以增添。同时，又定期地检查，将有富余的队列加以精简。

此外，slab管理方法还有一个特点，每种对象的缓冲区队列并非由各个对象直接构成，而是由一连串“大块（slab）”构成,而每个大块中则包含了若干同种的对象。一般而言，对象分两种，一种是大对象，一种是小对象。所谓小对象，是指在一个页面中可以包容下好几个对象的那一种。例如，一个inode的大小约300多个字节，因此一个页面可以容纳8个以上的inode，所以inode是小对象。内核中使用的大多数数据结构都是这样的小对象，所以，我们先来看小对象的组织和管理以及相应的slab结构。先看用于某种假象小对象的一个slab块的结构示意图。
