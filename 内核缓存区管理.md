
## Memory-Management

可想而知，内核在运行中常常需要使用一些缓冲区。例如，当要建立一个新的进程时就要增加一个task_struct结构，而当进程撤销时就要释放本进程的task结构。这些小块存储空间的使用并不局限某一个子进程，否则就可以作为这个子程序的局部变量而使用堆栈空间了。另外，这些小块存储空间又是动态变化的，不像用于页面管理的page结构那样，有多大的内存就有多少个page结构，构成一个静态的阵列。由于事先根本分无法预测运行中各种不同数据结构对缓存区的需求，不适合为每一种可能用到的数据结构建立一个“缓冲池”，因为那样的话很可能会出现有些缓存池已经用尽而有些缓冲池中却有大量缓冲区的局面。因此，只能采用更具有全局性的方法。

那么，用什么样的方法呢，如果采用像用户空间的malloc那样的动态分配办法，从一个统一的存储空间“堆”（heap）中，需要多少就切多大一块，不用就归还，则有几个缺点需要考虑改进：

* 久而久之，会使存储堆“碎片化”，以至虽然存储堆中空闲空间的总量足够大，却无法分配所需大小的连续空间。为此，一般都采用按2的次幂的大小分配空间，以缓解碎片化。

* 每次分配得到所需大小的缓冲区以后，都要进行初始化。内核中频繁地使用一些数据结构，这些数据结构中相当一部分成分需要某些特殊的初始化（例如队列头部等）而并非简单地清成0。如果释放的数据结构可以在下次分配时“重用”而无需初始化，那就可以提高内核的效率。
