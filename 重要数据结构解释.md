
pdlist_data_t用于表示结点的节本元素：

```c++
typedef struct pglist_data {

    struct zone node_zones[MAX_NR_ZONES];
    struct zonelist node_zonelists[MAX_ZONELISTS];
    int nr_zones;
#ifdef CONFIG_FLAT_NODE_MEM_MAP /* means !SPARSEMEM */
    struct page *node_mem_map;
#ifdef CONFIG_CGROUP_MEM_RES_CTLR
    struct page_cgroup *node_page_cgroup;
#endif
#endif
    struct bootmem_data *bdata;
#ifdef CONFIG_MEMORY_HOTPLUG
    spinlock_t node_size_lock;
#endif
    unsigned long node_start_pfn;
    unsigned long node_present_pages; /* 物理页的总数 * /
    unsigned long node_spanned_pages; /* 物理页总长度，包含洞 */
    int node_id;
    wait_queue_head_t kswapd_wait;
    struct task_struct *kswapd;
    int kswapd_max_order;

} pg_data_t;
```

zonelist结构体：

```C++
typedef struct zonelist_struct {

    zone_t * zones [MAX_NR_ZONES+1]; //指针数组，指向每个具体的页面管理区
    int gfp_mask; //表示分配策略

}   zonelist_t;
```

struct zone结构体：

```C++
struct zone {
	/* Fields commonly accessed by the page allocator */
	unsigned long		pages_min, pages_low, pages_high;//如果空闲页多于pages_high，则内存域的状态时理想的；如果空闲页的数目低于pages_low，则内核开始将页换出到硬盘；如果空闲页低于pages_min，那么页回收工作的压力就比较大，因为内核中急需空闲页。
	
	unsigned long		lowmem_reserve[MAX_NR_ZONES];//分别为各种内存域指定了若干页，用于一些无论如何都不能失败的关键性内存分配。

#ifdef CONFIG_NUMA
	int node;
	/*
	 * zone reclaim becomes active if more unmapped pages exist.
	 */
	unsigned long		min_unmapped_pages;
	unsigned long		min_slab_pages;
	struct per_cpu_pageset	*pageset[NR_CPUS];
#else
	struct per_cpu_pageset	pageset[NR_CPUS];//这个数组用于实现每个CPU的热/冷页帧列表。内核使用这些列表来保存可用于满足实现的“新鲜”页。但冷热页帧对应的高速缓存状态不同：有些页帧很可能在高速缓存中，因此可以快速访问，故称之为热的；未缓存的页帧与此相对，称之为冷的。
#endif
	/*
	 * free areas of different sizes
	 */
	spinlock_t		lock;
#ifdef CONFIG_MEMORY_HOTPLUG
	/* see spanned/present_pages for more description */
	seqlock_t		span_seqlock;
#endif
	struct free_area	free_area[MAX_ORDER];//用于实现伙伴系统，每个数组元素都表示某种固定长度的一些连续内存区，对于包含在每个区域中的空闲内存页的管理，free_area是一个起点。

#ifndef CONFIG_SPARSEMEM
	unsigned long		*pageblock_flags;
#endif /* CONFIG_SPARSEMEM */


	ZONE_PADDING(_pad1_)

	//这一部分涉及的结构成员，用来根据活动情况对内存域中使用的页进行编目，如果页访问频繁，则内核认为它是活动的；而不活动的页则显然相反。在需要换出页时，这种区别是很重要的，如果可能的话，频繁使用的页应该保持不动，而多余的不活动的页则可以换出而没有什么影响。
	spinlock_t		lru_lock;	
	struct list_head	active_list;//活动页的集合
	struct list_head	inactive_list;//不活动页的集合
	unsigned long		nr_scan_active;//在回收内存时，需要扫描的活动页的数目
	unsigned long		nr_scan_inactive;//在回收内存时，需要扫描的不活动页的数目
	unsigned long		pages_scanned;//指定了上次换出一页一来，有多少页未能成功扫描
	unsigned long		flags;//描述了内存域的当前状态

	/* Zone statistics */
	atomic_long_t		vm_stat[NR_VM_ZONE_STAT_ITEMS];//维护了大量有关该内存域的统计信息

	
	int prev_priority;//存储了上一次扫描操作扫描该内存域的优先级


	ZONE_PADDING(_pad2_)
	/* Rarely used or read-mostly fields */

	//一下三个变量实现了一个等待队列，可用于等待某一页变为可用的进程，进程排成一个队列，等待某些条件，在条件变为真时，内核会通知进程恢复工作。
	wait_queue_head_t	* wait_table;
	unsigned long		wait_table_hash_nr_entries;
	unsigned long		wait_table_bits;

	
	struct pglist_data	*zone_pgdat;//建立内存域和父结点之间的关联
	/* zone_start_pfn == zone_start_paddr >> PAGE_SHIFT */
	unsigned long		zone_start_pfn;//内存域第一个页帧的索引

	unsigned long		spanned_pages;//指定内存域中页的总数，但并非所有的都可用，因为有空洞
	unsigned long		present_pages;//指定了内存域中实际上可用的页数目

	/*
	 * rarely used fields:
	 */
	const char		*name;//保存该内存域的惯用名称，目前有3个选项可用NORMAL DMA HIGHMEM
}____cacheline_internodealigned_in_smp;
```
