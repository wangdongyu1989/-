# Memory-Management

页式存储管理机制通过页面目录和页面表将每个线性地址（也可以理解为虚拟地址）转成物理地址。如果在这个过程中遇到某种阻碍使CPU无法最终访问到相应的物理内存单元，映射便失败了，当前的指令也就不能执行完成。此时CPU会产生一次页面错误（Page Fault）异常，进而执行预定的页面异常处理程序，使应用程序得以从因映射失败而暂停的指令处开始恢复执行，或进行一些善后处理。这里所说的阻碍可以有以下几种情况：

* 相应的页面目录或页面表项为空，也就是该线性地址与物理地址的映射关系尚未建立，或者已经撤销。
* 相应的物理页面不在内存中。
* 指令中规定的访问方式与页面的权限不符，例如企图打开一个“只读”的页面。

在这个情景里，我们假定一段用户曾经将一个已打开文件通过mmap()系统调用映射到内存，然后又已经将映射撤销(通过munmap系统调用)。在撤销一个映射区时，常常会在虚存地址空间中留下一个孤立的空洞，而相应的地址则不能继续使用了。但是，在用户程序中往往会有错误，以致在程序中某个地方还再次访问这个已经撤销的区域。这时候，一次因越界访问一个无效地址而引起映射失败，从而就产生一次页面出错异常。这里假定CPU的运行已经到达了页面异常服务程序的主体do_page_fault（）的入口：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405c.jpg "访问越界")
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170405d.jpg "访问越界")

首先是一行汇编码。当i386CPU产生“页面错”异常时，CPU将导致映射失败的线性地址放在控制寄存器cr2中，而这显然是相应的服务程序锁必需的信息。可以，在c语言中并没有相应的语言成分可以读取cr2的内容，所以只能用汇编代码。这行汇编代码只有输出部而没有输入部，它将%0与变量address相结合，并说明该变量应该分配在一个寄存器中。

同时，内核的中断/异常响应机制还传过来两个参数。一个是pt_regs结构指针regs，它指向例外发生前夕CPU中各寄存器内容的一份副本，这是由内核的中断响应机制保存下来的“现场”。而error_code则进一步指明映射失败的具体原因。

然后是获取当前进程的task_struct数据结构。在内核中，可以通过一个宏操作current取得当前进程(正在运行的进程)的task_struct结构的地址。在每个进程的task_struct结构中有一个指针，指向其mm_struct数据结构，而跟虚存管理和映射有关的信息都在那个结构中。这里要指出，CPU实际进行的映射并不涉及mm_struct结构，而是像以前讲过的那样通过页面目录和页面表进行，但是mm_struct结构反映了，或者说描述了这种映射。

接下来，需要检测两个服务情况。一个特殊情况是in_interrupt()返回非0，说明映射的失败发生在某个中断服务程序中，因而与当前进程毫无关系。另一个特殊情况是当前进程的mm指针为空，也就是说改进程的映射尚未建立，当然也就不可能与当前进程有关。可是，不跟当前进程有关，in_interrupt()又返回0，那这次异常发生在什么地方呢？其实还是在某个中断/异常服务程序中，只不过不在in_interrupt（）能检测到范围中而已。如果发生这些特殊情况，控制就通过goto语句转到标号no_cotext处，不过那与我们这个情景无关。

可以想像，在知道了发生映射失败的地址以及所属的进程之后，接下来应该要搞清楚的是这个地址是否落在某个已经建立的区间，或者进一步具体指出在哪个区间。事实正是这样，这就是find_vma()所要做的事情。find_vma（）试图在一个虚存空间中找出结束地址大于给定地址的第一个区间。如果找不到的话，那本次页面异常就必定是因越界访问引起。那么，在什么情况下会找不到呢？回忆一下内核对用户虚存空间的使用，堆栈在用户区的顶部，从上向下伸展，而进程的代码和数据都是自底向上分配空间。如果没有一个区间的结束地址高于给定的地址，那就是说明这个地址在堆栈之下，也就是3G字节之上了。要从用户空间访问属于系统的空间，那当然越界了，然后就转向bad_area。

如果找到了这一区间，而且其其实地址又不高于给定地址，那就说明给定地址恰好落在这个区间。这样，映射肯定已经建立，所以就给转向good_area去进一步检查失败的原因。

除了这两种情况，剩下的就是给定地址正落在两个区间当中的空洞里，也就是该地址所在页面的映射尚未建立或已撤销。在用户虚存空间中，可能有两种不同的空洞。第一种空洞只能有一个，那就是在堆栈区间一下的那个大空洞，它代表着动态分配(通过系统调用brk())而仍未分配出去的空间。当映射失败的地址落在这个空洞里时，还有个特殊情况考虑，将在以后讨论。但是，怎样才知道这个地址落在这个空洞里呢？我们知道，堆栈是向下伸展的，如果find_vma()找到的区间是堆栈区间，那么在它的vm_flags中应该有个标志位VM_GROWSDOWN。要是该标记位为0的话，那就说明空洞商贩的区间并非堆栈区，说明这个空洞是因为一个映射区间被撤销而留下的，或者是建立映射时跳过了一块地址。这就是第二种情况，也是我们这个情况所说的情况。

